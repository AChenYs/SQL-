# 5.1

***按照 product_id 升序排列，计算出截⾄当前⾏的最⾼ sale_price。***

***结果如下:***
|product_id|product_name|sale_price|Current_max_price|
|----------|------------|----------|-----------------|
|0001      |T恤          |1,000     |1,000            |
|0002      |打孔器         |500       |1,000            |
|0003      |运动T恤        |4,000     |4,000            |
|0004      |菜刀          |3,000     |4,000            |
|0005      |高压锅         |6,800     |6,800            |
|0006      |叉子          |500       |6,800            |
|0007      |擦菜板         |880       |6,800            |
|0008      |圆珠笔         |100       |6,800            |

# 5.2

***代码***

```
select product_id, product_name, sale_price, regist_date, sum(sale_price) over (order by -regist_date) as "总的价格"
from product;
```

***结果***
|product_id|product_name|sale_price|regist_date|总的价格  |
|----------|------------|----------|-----------|------|
|0003      |运动T恤        |4,000     |           |4,000 |
|0008      |圆珠笔         |100       |2009-11-11 |4,100 |
|0001      |T恤          |1,000     |2009-09-20 |8,600 |
|0004      |菜刀          |3,000     |2009-09-20 |8,600 |
|0006      |叉子          |500       |2009-09-20 |8,600 |
|0002      |打孔器         |500       |2009-09-11 |9,100 |
|0005      |高压锅         |6,800     |2009-01-15 |15,900|
|0007      |擦菜板         |880       |2008-04-28 |16,780|

# 5.3
***1.窗口函数不指定PARTITION BY的效果是没有指名排序序列，那就是全部的列正常地去排序。
2.本质上是因为 SQL 语句的执⾏顺序。
FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY
在select之前的语句是不能使用的，因为在执行select语句后前面语句进行的窗口函数排序都算无效了；
因为order by 语句在select 语句之后，所以就不会报错。***

# 5.4
***代码***

```
CREATE TABLE table(01~20) like shop.product;
```

***输入20次，然后刷新product.shop的表，就可以看到已经创建了20个表了***
